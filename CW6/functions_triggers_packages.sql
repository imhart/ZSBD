-- FUNKCJE

-- 1. Funkcja zwracająca nazwę pracy dla podanego id, z wyjątkiem jeśli nie istnieje
CREATE OR REPLACE FUNCTION f_job_name(p_job_id VARCHAR2) RETURN VARCHAR2 IS
  v_job_title jobs.job_title%TYPE;
BEGIN
  SELECT job_title INTO v_job_title FROM jobs WHERE job_id = p_job_id;
  RETURN v_job_title;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20001, 'Nie istnieje praca o podanym id');
END;
/

-- 2. Funkcja zwracająca roczne zarobki (12*miesięczne + premia) dla pracownika o podanym id
CREATE OR REPLACE FUNCTION f_roczne_zarobki(p_emp_id NUMBER) RETURN NUMBER IS
  v_salary employees.salary%TYPE;
  v_comm employees.commission_pct%TYPE;
BEGIN
  SELECT salary, commission_pct INTO v_salary, v_comm FROM employees WHERE employee_id = p_emp_id;
  RETURN 12 * v_salary + NVL(12 * v_salary * v_comm, 0);
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20002, 'Nie znaleziono pracownika o podanym id');
END;
/

-- 3. Funkcja biorąca w nawias numer kierunkowy z numeru telefonu
CREATE OR REPLACE FUNCTION f_numer_kierunkowy(p_phone VARCHAR2) RETURN VARCHAR2 IS
  v_code VARCHAR2(10);
BEGIN
  v_code := REGEXP_SUBSTR(p_phone, '\\(([^)]+)\\)', 1, 1, NULL, 1);
  RETURN v_code;
END;
/

-- 4. Funkcja zmieniająca pierwszą i ostatnią literę na wielką, reszta małe
CREATE OR REPLACE FUNCTION f_pierwsza_ostatnia_wielka(p_txt VARCHAR2) RETURN VARCHAR2 IS
  v_len NUMBER := LENGTH(p_txt);
BEGIN
  IF v_len = 0 THEN RETURN p_txt; END IF;
  IF v_len = 1 THEN RETURN UPPER(p_txt); END IF;
  RETURN UPPER(SUBSTR(p_txt,1,1)) || LOWER(SUBSTR(p_txt,2,v_len-2)) || UPPER(SUBSTR(p_txt,-1));
END;
/

-- 5. Funkcja przerabiająca PESEL na datę urodzenia yyyy-mm-dd
CREATE OR REPLACE FUNCTION f_pesel_to_date(p_pesel VARCHAR2) RETURN DATE IS
  v_year VARCHAR2(2);
  v_month VARCHAR2(2);
  v_day VARCHAR2(2);
  v_century NUMBER;
  v_full_year NUMBER;
  v_date DATE;
BEGIN
  v_year := SUBSTR(p_pesel,1,2);
  v_month := SUBSTR(p_pesel,3,2);
  v_day := SUBSTR(p_pesel,5,2);
  IF v_month BETWEEN '01' AND '12' THEN v_century := 1900;
  ELSIF v_month BETWEEN '21' AND '32' THEN v_century := 2000; v_month := TO_CHAR(TO_NUMBER(v_month)-20,'FM00');
  ELSIF v_month BETWEEN '81' AND '92' THEN v_century := 1800; v_month := TO_CHAR(TO_NUMBER(v_month)-80,'FM00');
  ELSE v_century := 1900; END IF;
  v_full_year := v_century + TO_NUMBER(v_year);
  v_date := TO_DATE(v_full_year||v_month||v_day,'YYYYMMDD');
  RETURN v_date;
END;
/

-- 6. Funkcja zwracająca liczbę pracowników i departamentów w kraju podanym jako parametr
CREATE OR REPLACE FUNCTION f_emp_dept_in_country(p_country VARCHAR2) RETURN VARCHAR2 IS
  v_emp NUMBER;
  v_dept NUMBER;
BEGIN
  SELECT COUNT(DISTINCT e.employee_id), COUNT(DISTINCT d.department_id)
    INTO v_emp, v_dept
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    JOIN locations l ON d.location_id = l.location_id
    JOIN countries c ON l.country_id = c.country_id
    WHERE c.country_name = p_country;
  RETURN 'Pracownicy: '||v_emp||', Departamenty: '||v_dept;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RAISE_APPLICATION_ERROR(-20003, 'Brak kraju o podanej nazwie');
END;
/

-- WYZWALACZE

-- 1. Tabela archiwum_departamentów i wyzwalacz po DELETE
CREATE TABLE archiwum_departamentow (
  id NUMBER,
  nazwa VARCHAR2(100),
  data_zamkniecia DATE,
  ostatni_manager VARCHAR2(100)
);
/
CREATE OR REPLACE TRIGGER trg_archiwum_departamentow
AFTER DELETE ON departments
FOR EACH ROW
DECLARE
  v_manager VARCHAR2(100);
BEGIN
  SELECT first_name || ' ' || last_name INTO v_manager FROM employees WHERE employee_id = :OLD.manager_id;
  INSERT INTO archiwum_departamentow VALUES (:OLD.department_id, :OLD.department_name, SYSDATE, v_manager);
EXCEPTION WHEN NO_DATA_FOUND THEN
  INSERT INTO archiwum_departamentow VALUES (:OLD.department_id, :OLD.department_name, SYSDATE, NULL);
END;
/

-- 2. Tabela złodziej i wyzwalacz na employees (INSERT/UPDATE salary)
CREATE TABLE zlodziej (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY,
  user_name VARCHAR2(100),
  czas_zmiany TIMESTAMP
);
/
CREATE OR REPLACE TRIGGER trg_salary_check
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
BEGIN
  IF :NEW.salary < 2000 OR :NEW.salary > 26000 THEN
    INSERT INTO zlodziej(user_name, czas_zmiany) VALUES (USER, SYSTIMESTAMP);
    RAISE_APPLICATION_ERROR(-20004, 'Wynagrodzenie poza dozwolonym zakresem!');
  END IF;
END;
/

-- 3. Sekwencja i wyzwalacz auto_increment dla employees
CREATE SEQUENCE seq_emp_id START WITH 1000 INCREMENT BY 1;
/
CREATE OR REPLACE TRIGGER trg_emp_autoinc
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
  IF :NEW.employee_id IS NULL THEN
    SELECT seq_emp_id.NEXTVAL INTO :NEW.employee_id FROM dual;
  END IF;
END;
/

-- 4. Wyzwalacz zabraniający operacji na JOD_GRADES
CREATE OR REPLACE TRIGGER trg_no_dml_jod_grades
BEFORE INSERT OR UPDATE OR DELETE ON JOD_GRADES
BEGIN
  RAISE_APPLICATION_ERROR(-20005, 'Operacje DML na JOD_GRADES są zabronione!');
END;
/

-- 5. Wyzwalacz blokujący zmianę min/max salary w jobs
CREATE OR REPLACE TRIGGER trg_jobs_salary_protect
BEFORE UPDATE OF min_salary, max_salary ON jobs
FOR EACH ROW
BEGIN
  :NEW.min_salary := :OLD.min_salary;
  :NEW.max_salary := :OLD.max_salary;
END;
/

-- PACZKI

-- 1. Paczka z funkcjami i procedurami
CREATE OR REPLACE PACKAGE pkg_funkcje IS
  FUNCTION f_job_name(p_job_id VARCHAR2) RETURN VARCHAR2;
  FUNCTION f_roczne_zarobki(p_emp_id NUMBER) RETURN NUMBER;
  FUNCTION f_numer_kierunkowy(p_phone VARCHAR2) RETURN VARCHAR2;
  FUNCTION f_pierwsza_ostatnia_wielka(p_txt VARCHAR2) RETURN VARCHAR2;
  FUNCTION f_pesel_to_date(p_pesel VARCHAR2) RETURN DATE;
  FUNCTION f_emp_dept_in_country(p_country VARCHAR2) RETURN VARCHAR2;
END pkg_funkcje;
/
CREATE OR REPLACE PACKAGE BODY pkg_funkcje IS
  FUNCTION f_job_name(p_job_id VARCHAR2) RETURN VARCHAR2 IS
    v_job_title jobs.job_title%TYPE;
  BEGIN
    SELECT job_title INTO v_job_title FROM jobs WHERE job_id = p_job_id;
    RETURN v_job_title;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20001, 'Nie istnieje praca o podanym id');
  END;
  FUNCTION f_roczne_zarobki(p_emp_id NUMBER) RETURN NUMBER IS
    v_salary employees.salary%TYPE;
    v_comm employees.commission_pct%TYPE;
  BEGIN
    SELECT salary, commission_pct INTO v_salary, v_comm FROM employees WHERE employee_id = p_emp_id;
    RETURN 12 * v_salary + NVL(12 * v_salary * v_comm, 0);
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20002, 'Nie znaleziono pracownika o podanym id');
  END;
  FUNCTION f_numer_kierunkowy(p_phone VARCHAR2) RETURN VARCHAR2 IS
    v_code VARCHAR2(10);
  BEGIN
    v_code := REGEXP_SUBSTR(p_phone, '\\(([^)]+)\\)', 1, 1, NULL, 1);
    RETURN v_code;
  END;
  FUNCTION f_pierwsza_ostatnia_wielka(p_txt VARCHAR2) RETURN VARCHAR2 IS
    v_len NUMBER := LENGTH(p_txt);
  BEGIN
    IF v_len = 0 THEN RETURN p_txt; END IF;
    IF v_len = 1 THEN RETURN UPPER(p_txt); END IF;
    RETURN UPPER(SUBSTR(p_txt,1,1)) || LOWER(SUBSTR(p_txt,2,v_len-2)) || UPPER(SUBSTR(p_txt,-1));
  END;
  FUNCTION f_pesel_to_date(p_pesel VARCHAR2) RETURN DATE IS
    v_year VARCHAR2(2);
    v_month VARCHAR2(2);
    v_day VARCHAR2(2);
    v_century NUMBER;
    v_full_year NUMBER;
    v_date DATE;
  BEGIN
    v_year := SUBSTR(p_pesel,1,2);
    v_month := SUBSTR(p_pesel,3,2);
    v_day := SUBSTR(p_pesel,5,2);
    IF v_month BETWEEN '01' AND '12' THEN v_century := 1900;
    ELSIF v_month BETWEEN '21' AND '32' THEN v_century := 2000; v_month := TO_CHAR(TO_NUMBER(v_month)-20,'FM00');
    ELSIF v_month BETWEEN '81' AND '92' THEN v_century := 1800; v_month := TO_CHAR(TO_NUMBER(v_month)-80,'FM00');
    ELSE v_century := 1900; END IF;
    v_full_year := v_century + TO_NUMBER(v_year);
    v_date := TO_DATE(v_full_year||v_month||v_day,'YYYYMMDD');
    RETURN v_date;
  END;
  FUNCTION f_emp_dept_in_country(p_country VARCHAR2) RETURN VARCHAR2 IS
    v_emp NUMBER;
    v_dept NUMBER;
  BEGIN
    SELECT COUNT(DISTINCT e.employee_id), COUNT(DISTINCT d.department_id)
      INTO v_emp, v_dept
      FROM employees e
      JOIN departments d ON e.department_id = d.department_id
      JOIN locations l ON d.location_id = l.location_id
      JOIN countries c ON l.country_id = c.country_id
      WHERE c.country_name = p_country;
    RETURN 'Pracownicy: '||v_emp||', Departamenty: '||v_dept;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RAISE_APPLICATION_ERROR(-20003, 'Brak kraju o podanej nazwie');
  END;
END pkg_funkcje;
/

-- 2. Paczka CRUD dla REGIONS
CREATE OR REPLACE PACKAGE pkg_regions IS
  PROCEDURE add_region(p_id NUMBER, p_name VARCHAR2);
  PROCEDURE update_region(p_id NUMBER, p_name VARCHAR2);
  PROCEDURE delete_region(p_id NUMBER);
  FUNCTION get_region_by_id(p_id NUMBER) RETURN VARCHAR2;
  FUNCTION get_regions_by_name(p_name VARCHAR2) RETURN SYS_REFCURSOR;
END pkg_regions;
/
CREATE OR REPLACE PACKAGE BODY pkg_regions IS
  PROCEDURE add_region(p_id NUMBER, p_name VARCHAR2) IS
  BEGIN
    INSERT INTO regions(region_id, region_name) VALUES (p_id, p_name);
  END;
  PROCEDURE update_region(p_id NUMBER, p_name VARCHAR2) IS
  BEGIN
    UPDATE regions SET region_name = p_name WHERE region_id = p_id;
  END;
  PROCEDURE delete_region(p_id NUMBER) IS
  BEGIN
    DELETE FROM regions WHERE region_id = p_id;
  END;
  FUNCTION get_region_by_id(p_id NUMBER) RETURN VARCHAR2 IS
    v_name VARCHAR2(50);
  BEGIN
    SELECT region_name INTO v_name FROM regions WHERE region_id = p_id;
    RETURN v_name;
  EXCEPTION WHEN NO_DATA_FOUND THEN RETURN NULL; END;
  FUNCTION get_regions_by_name(p_name VARCHAR2) RETURN SYS_REFCURSOR IS
    rc SYS_REFCURSOR;
  BEGIN
    OPEN rc FOR SELECT * FROM regions WHERE region_name LIKE '%'||p_name||'%';
    RETURN rc;
  END;
END pkg_regions;
/ 